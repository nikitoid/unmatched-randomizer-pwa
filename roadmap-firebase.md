# Roadmap: Интеграция Firebase (Firestore)

Этот документ описывает пошаговый план по интеграции Firebase Firestore в приложение для реализации функционала облачных списков.

## Этап 1: Настройка и инициализация Firebase

**Задача:** Подключить Firebase SDK и настроить инициализацию приложения, включая временную конфигурацию для локальной разработки.

1.  **Создать файл `js/firebase-config.js`:**

    - Этот файл будет экспортировать объект конфигурации Firebase.
    - Он будет проверять наличие `process.env.FIREBASE_CONFIG` (для Netlify).
    - Если переменная окружения недоступна (локальная разработка), он будет использовать "заглушку" - временный объект конфигурации, жестко прописанный в этом же файле.
    - **ВАЖНО:** Временный объект конфигурации должен быть четко помечен комментариями, призывающими к его удалению перед деплоем.

2.  **Создать файл `js/modules/firebase.js`:**

    - Импортировать `initializeApp` из `firebase/app` и `getFirestore`, `connectFirestoreEmulator` из `firebase/firestore`.
    - Импортировать конфигурацию из `js/firebase-config.js`.
    - Создать класс `FirebaseManager` с методами:
      - `constructor()`: инициализирует `this.db = null;`.
      - `init()`:
        - Вызывает `initializeApp` с импортированной конфигурацией.
        - Вызывает `getFirestore` для получения инстанса БД и сохраняет его в `this.db`.
        - **Для локальной разработки:** добавить блок `if (window.location.hostname === "localhost")`, в котором вызывать `connectFirestoreEmulator` для подключения к локальному эмулятору Firestore. Пометить этот блок как временный.
    - Создать и экспортировать синглтон-экземпляр: `export const firebaseManager = new FirebaseManager();`.

3.  **Обновить `js/app.js`:**

    - Импортировать `firebaseManager`.
    - Внутри `DOMContentLoaded`, вызвать `firebaseManager.init();` для инициализации Firebase при старте приложения.

4.  **Обновить `index.html`:**

    - Добавить скрипты Firebase SDK (App и Firestore) через CDN перед основным скриптом `app.js`.

    ```html
    <!-- Firebase -->
    <script
      src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"
      defer
    ></script>
    <script
      src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"
      defer
    ></script>
    ```

## Этап 2: Модификация `storage.js` и `listManager.js` для поддержки "типов" списков

**Задача:** Научить приложение различать `local` и `cloud` списки.

1.  **Доработать `js/modules/storage.js`:**

    - Структура хранения списков должна измениться. Вместо `{"listName": ["hero1", ...]}` она станет `{"listName": { "heroes": ["hero1", ...], "type": "local" | "cloud", "id": "firebase_doc_id" }}`. `id` будет только у облачных списков.
    - Обновить `loadHeroLists` и `saveHeroLists` для работы с новой структурой.
    - Написать миграционную логику в `initializeAppState` (`app.js`): при первой загрузке после обновления, если списки в старом формате, они должны быть конвертированы в новый формат с `type: "local"`.

2.  **Доработать `js/modules/listManager.js`:**
    - В `createManagerHTML` добавить визуальное различие для облачных списков. Рядом с названием списка, если `list.type === 'cloud'`, отображать иконку облака.
    - Добавить логику, которая будет блокировать кнопки "Переименовать" и "Удалить" для облачных списков в офлайн-режиме (понадобится метод `isOnline` из `firebase.js`).
    - При создании нового списка (`handleCreateList`) по умолчанию присваивать ему `type: "local"`.

## Этап 3: Реализация основной логики `firebase.js`

**Задача:** Реализовать методы для работы с Firestore.

1.  **Дополнить `js/modules/firebase.js`:**
    - **`isOnline()`**: Добавить метод для проверки статуса сети (`navigator.onLine`).
    - **`uploadList(listName, listData)`**:
      - Принимает имя и данные локального списка.
      - Создает новый документ в коллекции `lists` в Firestore.
      - Возвращает `id` созданного документа.
    - **`syncList(listId, listData)`**:
      - Принимает ID документа и обновленные данные списка.
      - Обновляет соответствующий документ в Firestore.
    - **`fetchList(listId)`**:
      - Получает документ из Firestore по его `id`.
    - **`deleteCloudList(listId)`**:
      - Удаляет документ из Firestore.
    - **`fetchAllCloudLists()`**:
      - Подписывается на изменения в коллекции `lists` (используя `onSnapshot`). При получении данных, инициирует событие (например, `CustomEvent`), передавая списки для синхронизации с `localStorage`.

## Этап 4: Интеграция `firebase.js` с остальным приложением

**Задача:** Связать модуль `firebase.js` с `storage.js` и `listManager.js`.

1.  **В `js/modules/storage.js`:**

    - Импортировать `firebaseManager`.
    - При изменении или удалении списка с `type: "cloud"`, вызывать соответствующие методы `firebaseManager.syncList()` или `firebaseManager.deleteCloudList()`.

2.  **В `js/app.js`:**

    - Подписаться на событие `fetchAllCloudLists` от `firebaseManager`.
    - В обработчике этого события:
      - Получить облачные списки.
      - Сравнить их с данными в `localStorage`.
      - Аккуратно смержить изменения: обновить существующие, добавить новые, удалить удаленные.
      - После мержа, вызвать `updateHeroSelect()` для обновления UI.

3.  **В `js/modules/listManager.js`:**
    - Добавить кнопку "Загрузить в облако" для локальных списков.
    - По клику на нее вызывать `firebaseManager.uploadList()`.
    - После успешной загрузки, обновить тип списка в `localStorage` на `cloud` и сохранить полученный `id`.

## Этап 5: UI и UX улучшения

**Задача:** Обеспечить пользователю понятную обратную связь.

1.  **Индикаторы статуса:**
    - В `listManager.js` рядом с облачными списками добавить иконку-статус (например, "синхронизировано", "синхронизация...", "ошибка"). Статус будет обновляться в зависимости от ответов от `firebase.js`.
2.  **Toast-уведомления:**
    - Использовать `Toast.js` для информирования пользователя о статусе сети ("Соединение восстановлено, синхронизация...", "Нет подключения к сети, облачные функции ограничены").
3.  **Офлайн-режим:**
    - В `listManager.js` и других частях UI, где есть взаимодействие с облачными списками, проверять `firebaseManager.isOnline()`. Если офлайн, блокировать соответствующие кнопки (редактирование, удаление облачного списка) и показывать уведомление.

После выполнения этих шагов, приложение будет поддерживать два типа списков, с возможностью синхронизации облачных списков через Firebase, сохраняя при этом полную функциональность в офлайн-режиме для локальных данных.
